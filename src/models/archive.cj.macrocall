package lrr4cj.models

import cjoy.json.*
import std.database.sql.*
import lrr4cj.config.*
import std.collection.*

/**
 * 归档数据模型
 */
/* ===== Emitted by MacroCall @Json in archive.cj:11:1 ===== */
/* 11.1 */public class Archive <: JsonSerializable & JsonDeserializable < Archive > & Jsonable {
/* 11.2 */    public var id: String = ""
/* 11.3 */    
/* 11.4 */    public var title: String = ""
/* 11.5 */    
/* 11.6 */    public var filename: String = ""
/* 11.7 */    
/* 11.8 */    public var summary: String = ""
/* 11.9 */    
/* 11.10 */    public var thumbhash: String = ""
/* 11.11 */    
/* 11.12 */    public var created_at: String = ""
/* 11.13 */    
/* 11.14 */    public var updated_at: String = ""
/* 11.15 */    
/* 11.16 */    public var relative_path: String = ""
/* 11.17 */    
/* 11.18 */    public var file_size: Int64 = 0
/* 11.19 */    
/* 11.20 */    public var isNew: Bool = false
/* 11.21 */    
/* 11.22 */    public var pagecount: Int32 = 0
/* 11.23 */    
/* 11.24 */    public var last_read_time: String = ""
/* 11.25 */    
/* 11.26 */    public var progress: Int32 = 0
/* 11.27 */    
/* 11.28 */    
/* 11.29 */    
/* 11.30 */    public init(id!: String = "", title!: String = "", filename!: String = "", summary!: String = "", thumbhash!: String = "", created_at!: String = "", updated_at!: String = "", relative_path!: String = "", file_size!: Int64 = 0, isNew!: Bool = false, pagecount!: Int32 = 0, last_read_time!: String = "", progress!: Int32 = 0) {
/* 11.31 */        this.id = id
/* 11.32 */        this.title = title
/* 11.33 */        this.filename = filename
/* 11.34 */        this.summary = summary
/* 11.35 */        this.thumbhash = thumbhash
/* 11.36 */        this.created_at = created_at
/* 11.37 */        this.updated_at = updated_at
/* 11.38 */        this.relative_path = relative_path
/* 11.39 */        this.file_size = file_size
/* 11.40 */        this.isNew = isNew
/* 11.41 */        this.pagecount = pagecount
/* 11.42 */        this.last_read_time = last_read_time
/* 11.43 */        this.progress = progress
/* 11.44 */    }
/* 11.45 */    
/* 11.46 */    
/* 11.47 */    
/* 11.48 */    public func toJson(writer: JsonWriter): Unit {
/* 11.49 */        writer.startObject()
/* 11.50 */        
/* 11.51 */        write(writer)
/* 11.52 */        writer.endObject()
/* 11.53 */    }
/* 11.54 */    
/* 11.55 */    protected func write(writer: JsonWriter): Unit {
/* 11.56 */        writer.writeName("arcid").writeValue(id)
/* 11.57 */        writer.writeName("title").writeValue(title)
/* 11.58 */        writer.writeName("filename").writeValue(filename)
/* 11.59 */        writer.writeName("summary").writeValue(summary)
/* 11.60 */        writer.writeName("thumbhash").writeValue(thumbhash)
/* 11.61 */        writer.writeName("created_at").writeValue(created_at)
/* 11.62 */        writer.writeName("updated_at").writeValue(updated_at)
/* 11.63 */        writer.writeName("relative_path").writeValue(relative_path)
/* 11.64 */        writer.writeName("file_size").writeValue(file_size)
/* 11.65 */        writer.writeName("isnew").writeValue(isNew)
/* 11.66 */        writer.writeName("pagecount").writeValue(pagecount)
/* 11.67 */        writer.writeName("last_read_time").writeValue(last_read_time)
/* 11.68 */        writer.writeName("progress").writeValue(progress)
/* 11.69 */        
/* 11.70 */    }
/* 11.71 */    
/* 11.72 */    
/* 11.73 */    protected static func read(obj: Archive, name: String, reader: JsonReader): Bool {
/* 11.74 */        match(name) {
/* 11.75 */            case "arcid" => obj.id = reader.readValue < String >()
/* 11.76 */            case "title" => obj.title = reader.readValue < String >()
/* 11.77 */            case "filename" => obj.filename = reader.readValue < String >()
/* 11.78 */            case "summary" => obj.summary = reader.readValue < String >()
/* 11.79 */            case "thumbhash" => obj.thumbhash = reader.readValue < String >()
/* 11.80 */            case "created_at" => obj.created_at = reader.readValue < String >()
/* 11.81 */            case "updated_at" => obj.updated_at = reader.readValue < String >()
/* 11.82 */            case "relative_path" => obj.relative_path = reader.readValue < String >()
/* 11.83 */            case "file_size" => obj.file_size = reader.readValue < Int64 >()
/* 11.84 */            case "isnew" => obj.isNew = reader.readValue < Bool >()
/* 11.85 */            case "pagecount" => obj.pagecount = reader.readValue < Int32 >()
/* 11.86 */            case "last_read_time" => obj.last_read_time = reader.readValue < String >()
/* 11.87 */            case "progress" => obj.progress = reader.readValue < Int32 >()
/* 11.88 */            
/* 11.89 */            case _ => return true
/* 11.90 */        }
/* 11.91 */        return false
/* 11.92 */    }
/* 11.93 */    
/* 11.94 */    public static func fromJson(reader: JsonReader): Archive {
/* 11.95 */        var obj = Archive()
/* 11.96 */        while(let Some(v) <- reader.peek()) {
/* 11.97 */            match(v) {
/* 11.98 */                case BeginObject =>
/* 11.99 */                reader.startObject()
/* 11.100 */                while(reader.peek() != EndObject) {
/* 11.101 */                    let name = reader.readName()
/* 11.102 */                    let skip = read(obj, name, reader)
/* 11.103 */                    if(skip) { reader.skip() }
/* 11.104 */                }
/* 11.105 */                reader.endObject()
/* 11.106 */                break
/* 11.107 */                case _ => throw Exception("the token is not start object")
/* 11.108 */            }
/* 11.109 */        }
/* 11.110 */        obj
/* 11.111 */    }
/* 11.112 */    
/* 11.113 */    
/* 11.114 */    protected static func schemaInfos(): Array < JsonSchemaInfo > {
/* 11.115 */        let arr = ArrayList < JsonSchemaInfo >([JsonSchemaInfo("arcid", schemaType: JsonTool.getSchema < String >(), description: "", required: true),
/* 11.116 */        JsonSchemaInfo("title", schemaType: JsonTool.getSchema < String >(), description: "", required: true),
/* 11.117 */        JsonSchemaInfo("filename", schemaType: JsonTool.getSchema < String >(), description: "", required: true),
/* 11.118 */        JsonSchemaInfo("summary", schemaType: JsonTool.getSchema < String >(), description: "", required: true),
/* 11.119 */        JsonSchemaInfo("thumbhash", schemaType: JsonTool.getSchema < String >(), description: "", required: true),
/* 11.120 */        JsonSchemaInfo("created_at", schemaType: JsonTool.getSchema < String >(), description: "", required: true),
/* 11.121 */        JsonSchemaInfo("updated_at", schemaType: JsonTool.getSchema < String >(), description: "", required: true),
/* 11.122 */        JsonSchemaInfo("relative_path", schemaType: JsonTool.getSchema < String >(), description: "", required: true),
/* 11.123 */        JsonSchemaInfo("file_size", schemaType: JsonTool.getSchema < Int64 >(), description: "", required: true),
/* 11.124 */        JsonSchemaInfo("isnew", schemaType: JsonTool.getSchema < Bool >(), description: "", required: true),
/* 11.125 */        JsonSchemaInfo("pagecount", schemaType: JsonTool.getSchema < Int32 >(), description: "", required: true),
/* 11.126 */        JsonSchemaInfo("last_read_time", schemaType: JsonTool.getSchema < String >(), description: "", required: true),
/* 11.127 */        JsonSchemaInfo("progress", schemaType: JsonTool.getSchema < Int32 >(), description: "", required: true)])
/* 11.128 */        
/* 11.129 */        arr.toArray()
/* 11.130 */    }
/* 11.131 */    
/* 11.132 */    public static func toSchema(): JsonSchemaType {
/* 11.133 */        JsonSchemaType.Obj(Archive.schemaInfos())
/* 11.134 */    }
/* 11.135 */    
/* 11.136 */    public static func toJsonSchema(): JsonSerializable {
/* 11.137 */        toSchema().toJson(description: "")
/* 11.138 */    }
/* 11.139 */    
/* 11.140 */    
/* 11.141 */}
/* 11.142 */
/* 11.143 */
/* ===== End of the Emit ===== */

/**
 * 归档数据访问层
 */
public class ArchiveModel {
    /**
     * 获取所有归档
     */
    public static func getAllArchives(): Array<Archive> {
        let connOpt = DatabaseConfig.createConnection()
        match (connOpt) {
            case Some(conn) =>
                var archives: ArrayList<Archive> = ArrayList<Archive>()
                try {
                    let stmt = conn.prepareStatement("SELECT arcid, title, filename, summary, thumbhash, created_at, updated_at, relative_path, file_size, isnew, pagecount, last_read_time, progress FROM archives ORDER BY id")
                    let rs = stmt.query()
                    
                    while (rs.next()) {
                        let archive = Archive()
                        archive.id = rs.getOrNull<String>(1) ?? ""
                        archive.title = rs.getOrNull<String>(2) ?? ""
                        archive.filename = rs.getOrNull<String>(3) ?? ""
                        archive.summary = rs.getOrNull<String>(4) ?? ""
                        archive.thumbhash = rs.getOrNull<String>(5) ?? ""
                        archive.created_at = rs.getOrNull<String>(6) ?? ""
                        archive.updated_at = rs.getOrNull<String>(7) ?? ""
                        archive.relative_path = rs.getOrNull<String>(8) ?? ""
                        archive.file_size = rs.getOrNull<Int64>(9) ?? 0
                        archive.isNew = rs.getOrNull<Bool>(10) ?? false
                        archive.pagecount = rs.getOrNull<Int32>(11) ?? 0
                        archive.last_read_time = rs.getOrNull<String>(12) ?? ""
                        archive.progress = rs.getOrNull<Int32>(13) ?? 0
                        archives.add(archive)
                    }
                    
                    conn.close()
                    return archives.toArray()
                } catch (e: Exception) {
                    println("查询归档失败: ${e}")
                    conn.close()
                    return Array<Archive>()
                }
            case None =>
                println("无法连接到数据库")
                return Array<Archive>()
        }
    }
    
    /**
     * 根据 ID 获取归档
     */
    public static func getArchiveById(id: String): Archive {
        let connOpt = DatabaseConfig.createConnection()
        match (connOpt) {
            case Some(conn) =>
                try {
                    let stmt = conn.prepareStatement("SELECT arcid, title, filename, summary, thumbhash, created_at, updated_at, relative_path, file_size, isnew, pagecount, last_read_time, progress FROM archives WHERE arcid = ?")
                    stmt.set(1, id)
                    let rs = stmt.query()
                    
                    if (rs.next()) {
                        let archive = Archive()
                        archive.id = rs.getOrNull<String>(1) ?? ""
                        archive.title = rs.getOrNull<String>(2) ?? ""
                        archive.filename = rs.getOrNull<String>(3) ?? ""
                        archive.summary = rs.getOrNull<String>(4) ?? ""
                        archive.thumbhash = rs.getOrNull<String>(5) ?? ""
                        archive.created_at = rs.getOrNull<String>(6) ?? ""
                        archive.updated_at = rs.getOrNull<String>(7) ?? ""
                        archive.relative_path = rs.getOrNull<String>(8) ?? ""
                        archive.file_size = rs.getOrNull<Int64>(9) ?? 0
                        archive.isNew = rs.getOrNull<Bool>(10) ?? false
                        archive.pagecount = rs.getOrNull<Int32>(11) ?? 0
                        archive.last_read_time = rs.getOrNull<String>(12) ?? ""
                        archive.progress = rs.getOrNull<Int32>(13) ?? 0
                        
                        conn.close()
                        return archive
                    }
                    
                    conn.close()
                } catch (e: Exception) {
                    println("查询归档失败: ${e}")
                    conn.close()
                }
            case None =>
                println("无法连接到数据库")
        }
        return Archive()
    }
    
    /**
     * 搜索归档
     */
    public static func searchArchives(filter: String, category: String, start: Int32, count: Int32): Array<Archive> {
        let connOpt = DatabaseConfig.createConnection()
        match (connOpt) {
            case Some(conn) =>
                var archives: ArrayList<Archive> = ArrayList<Archive>()
                try {
                    var sql = "SELECT arcid, title, filename, summary, thumbhash, created_at, updated_at, relative_path, file_size, isnew, pagecount, last_read_time, progress FROM archives"
                    
                    if (filter.size > 0) {
                        sql += " WHERE title LIKE ? OR filename LIKE ?"
                    }
                    
                    sql += " ORDER BY id LIMIT ? OFFSET ?"
                    
                    let stmt = conn.prepareStatement(sql)
                    
                    if (filter.size > 0) {
                        stmt.set(1, "%${filter}%")
                        stmt.set(2, "%${filter}%")
                        stmt.set(3, count)
                        stmt.set(4, start)
                    } else {
                        stmt.set(1, count)
                        stmt.set(2, start)
                    }
                    
                    let rs = stmt.query()
                    
                    while (rs.next()) {
                        let archive = Archive()
                        archive.id = rs.getOrNull<String>(1) ?? ""
                        archive.title = rs.getOrNull<String>(2) ?? ""
                        archive.filename = rs.getOrNull<String>(3) ?? ""
                        archive.summary = rs.getOrNull<String>(4) ?? ""
                        archive.thumbhash = rs.getOrNull<String>(5) ?? ""
                        archive.created_at = rs.getOrNull<String>(6) ?? ""
                        archive.updated_at = rs.getOrNull<String>(7) ?? ""
                        archive.relative_path = rs.getOrNull<String>(8) ?? ""
                        archive.file_size = rs.getOrNull<Int64>(9) ?? 0
                        archive.isNew = rs.getOrNull<Bool>(10) ?? false
                        archive.pagecount = rs.getOrNull<Int32>(11) ?? 0
                        archive.last_read_time = rs.getOrNull<String>(12) ?? ""
                        archive.progress = rs.getOrNull<Int32>(13) ?? 0
                        archives.add(archive)
                    }
                    
                    conn.close()
                    return archives.toArray()
                } catch (e: Exception) {
                    println("搜索归档失败: ${e}")
                    conn.close()
                    return Array<Archive>()
                }
            case None =>
                println("无法连接到数据库")
                return Array<Archive>()
        }
    }
    
    /**
     * 获取归档元数据
     */
    public static func getArchiveMetadata(id: String): Archive {
        return getArchiveById(id)
    }
    
    /**
     * 获取归档缩略图
     */
    public static func getArchiveThumbnail(id: String): String {
        return "/api/archives/${id}/thumbnail"
    }
    
    /**
     * 获取归档文件
     */
    public static func getArchiveFile(id: String): String {
        return "/api/archives/${id}/file"
    }
}