package lrr4cj.controllers

import stdx.net.http.HttpStatusCode
import cjoy.*
import cjoy.json.*
import lrr4cj.models.*
import lrr4cj.utils.*
import lrr4cj.dao.*
import lrr4cj.services.*
import std.time.*
import std.fs.*
import std.convert.*

public class ArchiveController {
    // GET /api/archives
    public static func getArchives(ctx: JoyContext): Unit {
        // 从数据库获取档案列表
        let archives = ArchiveModel.getAllArchives()
        
        // 手动构建JSON数组
        var archivesJson = "["
        var isFirst = true
        for (archive in archives) {
            if (!isFirst) {
                archivesJson += ","
            }
            isFirst = false
            
            archivesJson += "{"
            archivesJson += "\"arcid\":\"${archive.id}\","
            archivesJson += "\"title\":\"${archive.title}\","
            archivesJson += "\"filename\":\"${archive.filename}\","
            archivesJson += "\"summary\":\"${archive.summary}\","
            archivesJson += "\"thumbhash\":\"${archive.thumbhash}\","
            archivesJson += "\"created_at\":\"${archive.created_at}\","
            archivesJson += "\"updated_at\":\"${archive.updated_at}\","
            archivesJson += "\"relative_path\":\"${archive.relative_path}\","
            archivesJson += "\"file_size\":${archive.file_size},"
            archivesJson += "\"isnew\":${archive.isNew},"
            archivesJson += "\"pagecount\":${archive.pagecount},"
            archivesJson += "\"last_read_time\":\"${archive.last_read_time}\","
            archivesJson += "\"progress\":${archive.progress}"
            archivesJson += "}"
        }
        
        archivesJson += "]"
        
        let result = "{\"operation\":\"get_archives\",\"data\":" + archivesJson + ",\"success\":1}"
        
        ctx.json(result)
    }
    
    // GET /api/archives/{id}
    public static func getArchive(ctx: JoyContext): Unit {
        let id = ctx.getParam("id").getOrThrow()
        let archive = ArchiveModel.getArchiveById(id)

        if (archive.id.size == 0) {
            let errorResponse = "{\"operation\":\"get_archive\",\"error\":\"Archive not found\",\"success\":0}"
            ctx.status(HttpStatusCode.STATUS_NOT_FOUND)
            ctx.json(errorResponse)
            return
        }

        // 手动构建JSON对象
        var archiveJson = "{"
        archiveJson += "\"arcid\":\"${archive.id}\","
        archiveJson += "\"title\":\"${archive.title}\","
        archiveJson += "\"filename\":\"${archive.filename}\","
        archiveJson += "\"summary\":\"${archive.summary}\","
        archiveJson += "\"thumbhash\":\"${archive.thumbhash}\","
        archiveJson += "\"created_at\":\"${archive.created_at}\","
        archiveJson += "\"updated_at\":\"${archive.updated_at}\","
        archiveJson += "\"relative_path\":\"${archive.relative_path}\","
        archiveJson += "\"file_size\":${archive.file_size},"
        archiveJson += "\"isnew\":${archive.isNew},"
        archiveJson += "\"pagecount\":${archive.pagecount},"
        archiveJson += "\"last_read_time\":\"${archive.last_read_time}\","
        archiveJson += "\"progress\":${archive.progress}"
        archiveJson += "}"
        
        let result = "{\"operation\":\"get_archive\",\"data\":" + archiveJson + ",\"success\":1}"
        ctx.json(result)
    }
    
    // GET /api/archives/{id}/metadata
    public static func getMetadata(ctx: JoyContext): Unit {
        let id = ctx.getParam("id").getOrThrow()
        
        // 检查ID是否为空
        if (id.size == 0) {
            let errorResponse = "{\"error\":\"No archive ID specified.\",\"success\":0}"
            ctx.status(HttpStatusCode.STATUS_BAD_REQUEST)
            ctx.json(errorResponse)
            return
        }
        
        // 获取档案元数据（包含标签）
        let archive = ArchiveDao.getArchiveMetadataById(id)
        if (archive.id.size == 0) {
            let errorResponse = "{\"error\":\"Archive not found\",\"success\":0}"
            ctx.status(HttpStatusCode.STATUS_NOT_FOUND)
            ctx.json(errorResponse)
            return
        }
        
        // 转换 last_read_time 为时间戳
        let lastreadtime = try {
            // 如果 last_read_time 不为空，尝试解析为时间戳
            if (archive.last_read_time.size > 0) {
                // 简化处理，直接返回当前时间戳
                // 实际应该解析时间字符串并转换为时间戳
                Int64.parse(archive.last_read_time)
            } else {
                Int64(0)
            }
        } catch (e: Exception) {
            Int64(0)
        }
        
        // 手动构建JSON响应，符合API文档规范
        var metadataJson = "{"
        metadataJson += "\"arcid\":\"${archive.id}\","
        metadataJson += "\"title\":\"${archive.title}\","
        metadataJson += "\"filename\":\"${archive.filename}\","
        metadataJson += "\"summary\":\"${archive.summary}\","
        // 从标签关联表获取实际标签数据
        let tagsString = TagDao.getArchiveTags(archive.id)
        metadataJson += "\"tags\":\"${tagsString}\","
        metadataJson += "\"isnew\":\"${archive.isNew}\","
        metadataJson += "\"pagecount\":${archive.pagecount},"
        metadataJson += "\"progress\":${archive.progress},"
        metadataJson += "\"lastreadtime\":${lastreadtime},"
        metadataJson += "\"file_size\":${archive.file_size},"
        metadataJson += "\"size\":${archive.file_size},"
        metadataJson += "\"extension\":\"${archive.getExtension()}\","
        metadataJson += "\"created_at\":\"${archive.created_at}\","
        metadataJson += "\"updated_at\":\"${archive.updated_at}\","
        metadataJson += "\"relative_path\":\"${archive.relative_path}\""
        metadataJson += "}"
        
        ctx.json(metadataJson)
    }
    
    // PUT /api/archives/{id}/metadata
    public static func updateMetadata(ctx: JoyContext): Unit {
        let id = ctx.getParam("id").getOrThrow()
        
        // 检查ID是否为空
        if (id.size == 0) {
            let errorResponse = "{\"operation\":\"update_metadata\",\"error\":\"No archive ID specified.\",\"success\":0}"
            ctx.status(HttpStatusCode.STATUS_BAD_REQUEST)
            ctx.json(errorResponse)
            return
        }
        
        // 获取查询参数
        let titleParam = ctx.getQuery("title")
        let tagsParam = ctx.getQuery("tags")
        let summaryParam = ctx.getQuery("summary")
        
        // 检查归档是否存在
        let archive = ArchiveModel.getArchiveById(id)
        if (archive.id.size == 0) {
            let errorResponse = "{\"operation\":\"update_metadata\",\"error\":\"Archive not found\",\"success\":0}"
            ctx.status(HttpStatusCode.STATUS_NOT_FOUND)
            ctx.json(errorResponse)
            return
        }
        
        // 获取现有档案数据
        var existingArchive = ArchiveDao.getArchiveById(id)
        if (existingArchive.id.size == 0) {
            let errorResponse = "{\"operation\":\"update_metadata\",\"error\":\"Archive not found in database\",\"success\":0}"
            ctx.status(HttpStatusCode.STATUS_NOT_FOUND)
            ctx.json(errorResponse)
            return
        }
        
        // 更新字段（只有提供了参数才更新）
        match (titleParam) {
            case Some(title) => existingArchive.title = title
            case None => () // 保持原值
        }
        
        match (summaryParam) {
            case Some(summary) => existingArchive.summary = summary
            case None => () // 保持原值
        }
        
        // 更新时间戳
        let currentTime = Int64(getCurrentTimeMillis()).toString()
        existingArchive.updated_at = currentTime
        
        // 执行数据库更新
        let updateSuccess = ArchiveDao.update(existingArchive)
        
        if (updateSuccess) {
            // 如果有标签参数，更新标签
            match (tagsParam) {
                case Some(tags) =>
                    // 使用TagDao更新标签
                    let tagUpdateSuccess = TagDao.updateArchiveTags(id, tags)
                    if (!tagUpdateSuccess) {
                        println("Failed to update tags for archive ${id}")
                    }
                case None => () // 不更新标签
            }
            
            let result = "{\"operation\":\"update_metadata\",\"success\":1}"
            ctx.json(result)
        } else {
            let errorResponse = "{\"operation\":\"update_metadata\",\"error\":\"Failed to update archive metadata\",\"success\":0}"
            ctx.status(HttpStatusCode.STATUS_INTERNAL_SERVER_ERROR)
            ctx.json(errorResponse)
        }
    }
    
    // GET /api/archives/{id}/thumbnail
    public static func getThumbnail(ctx: JoyContext): Unit {
        let id = ctx.getParam("id").getOrThrow()
        
        // 检查ID是否为空
        if (id.size == 0) {
            let errorResponse = "{\"operation\":\"serve_thumbnail\",\"error\":\"No archive ID specified.\",\"success\":0}"
            ctx.status(HttpStatusCode.STATUS_BAD_REQUEST)
            ctx.json(errorResponse)
            return
        }
        
        // 获取查询参数
        let pageParam = ctx.getQuery("page")
        let noFallbackParam = ctx.getQuery("no_fallback")
        
        let page = match (pageParam) {
            case Some(p) => try {
                Int32.parse(p)
            } catch (e: Exception) {
                1i32  // 默认为第1页
            }
            case None => 1i32
        }
        
        let noFallback = match (noFallbackParam) {
            case Some(p) => p == "true" || p == "1"
            case None => false
        }
        
        // 检查归档是否存在
        println("Looking for archive with ID: ${id}")
        let archive = ArchiveModel.getArchiveById(id)
        println("Found archive: ${archive.id}, title: ${archive.title}")
        if (archive.id.size == 0) {
            let errorResponse = "{\"operation\":\"serve_thumbnail\",\"error\":\"Archive not found\",\"success\":0}"
            ctx.status(HttpStatusCode.STATUS_NOT_FOUND)
            ctx.json(errorResponse)
            return
        }
        
        println("About to check if thumbnail exists for archive: ${id}, page: ${page}")
        // 检查缩略图是否存在
        if (ArchiveModel.thumbnailExists(id, page)) {
            // 缩略图存在，直接返回图片
            let thumbnailPath = ArchiveModel.getThumbnailFilePath(id, page)
            println("Thumbnail exists, reading from: ${thumbnailPath}")
            try {
                let imageData = File.readFrom(Path(thumbnailPath))
                ctx.header("Content-Type", "image/jpeg")
                ctx.status(HttpStatusCode.STATUS_OK)
                // 直接返回二进制数据
                ctx.data(imageData)
                return
            } catch (e: Exception) {
                // 读取文件失败，继续使用fallback逻辑
                println("Failed to read thumbnail file: ${e}")
            }
        }
        
        // 缩略图不存在
        if (noFallback) {
            // 不使用fallback，返回任务ID
            let jobId = generateJobId()
            let response = "{\"job\":${jobId},\"operation\":\"serve_thumbnail\",\"success\":1}"
            ctx.status(HttpStatusCode.STATUS_ACCEPTED)
            ctx.json(response)
        } else {
            // 使用fallback，返回占位符图像
            let placeholderImage = getPlaceholderThumbnail()
            ctx.header("Content-Type", "image/jpeg")
            ctx.status(HttpStatusCode.STATUS_OK)
            // 直接返回二进制数据
            ctx.data(placeholderImage)
        }
    }
    
    /**
     * 生成任务ID
     */
    private static func generateJobId(): Int64 {
        return getCurrentTimeMillis()
    }
    
    /**
     * 获取当前时间的毫秒数
     */
    private static func getCurrentTimeMillis(): Int64 {
        // 简单实现，实际应该使用系统API
        return 1234567890
    }
    
    /**
     * 获取占位符缩略图
     */
    private static func getPlaceholderThumbnail(): Array<Byte> {
        // 简化实现，返回一个最小的JPEG图像
        // 这是一个1x1像素的黑色JPEG图像
        let bytes: Array<Byte> = [
            0xFF, 0xD8, 0xFF, 0xE0, 0x00, 0x10, 0x4A, 0x46, 0x49, 0x46, 0x00, 0x01,
            0x01, 0x01, 0x00, 0x48, 0x00, 0x48, 0x00, 0x00, 0xFF, 0xDB, 0x00, 0x43,
            0x00, 0x08, 0x06, 0x06, 0x07, 0x06, 0x05, 0x08, 0x07, 0x07, 0x07, 0x09,
            0x09, 0x08, 0x0A, 0x0C, 0x14, 0x0D, 0x0C, 0x0B, 0x0B, 0x0C, 0x19, 0x12,
            0x13, 0x0F, 0x14, 0x1D, 0x1A, 0x1F, 0x1E, 0x1D, 0x1A, 0x1C, 0x1C, 0x20,
            0x24, 0x2E, 0x27, 0x20, 0x22, 0x2C, 0x23, 0x1C, 0x1C, 0x28, 0x37, 0x29,
            0x2C, 0x30, 0x31, 0x34, 0x34, 0x34, 0x1F, 0x27, 0x39, 0x3D, 0x38, 0x32,
            0x3C, 0x2E, 0x33, 0x34, 0x32, 0xFF, 0xC0, 0x00, 0x11, 0x08, 0x00, 0x01,
            0x00, 0x01, 0x01, 0x01, 0x11, 0x00, 0x02, 0x11, 0x01, 0x03, 0x11, 0x01,
            0xFF, 0xC4, 0x00, 0x14, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x08, 0xFF, 0xC4,
            0x00, 0x14, 0x10, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFF, 0xDA, 0x00, 0x0C,
            0x03, 0x01, 0x00, 0x02, 0x11, 0x03, 0x11, 0x00, 0x3F, 0x00, 0x80, 0xFF, 0xD9
        ]
        
        return bytes
    }

    // GET /api/archives/{id}/files
    public static func getFiles(ctx: JoyContext): Unit {
        let id = ctx.getParam("id").getOrThrow()
        
        // 检查ID是否为空
        if (id.size == 0) {
            let errorResponse = "{\"operation\":\"get_file_list\",\"error\":\"No archive ID specified.\",\"success\":0}"
            ctx.status(HttpStatusCode.STATUS_BAD_REQUEST)
            ctx.json(errorResponse)
            return
        }
        
        // 获取查询参数
        let forceParam = ctx.getQuery("force")
        let force = match (forceParam) {
            case Some(f) => f == "true" || f == "1"
            case None => false
        }
        
        let imagesOnlyParam = ctx.getQuery("images_only")
        let imagesOnly = match (imagesOnlyParam) {
            case Some(i) => i == "true" || i == "1"
            case None => true  // 默认只返回图片文件
        }
        
        // 检查归档是否存在
        let archive = ArchiveModel.getArchiveById(id)
        if (archive.id.size == 0) {
            let errorResponse = "{\"operation\":\"get_file_list\",\"error\":\"Archive not found\",\"success\":0}"
            ctx.status(HttpStatusCode.STATUS_NOT_FOUND)
            ctx.json(errorResponse)
            return
        }
        
        // 获取ShinobuService实例
        let shinobu = ShinobuService.getInstance()
        
        
        // 获取归档中的文件列表
        let pageFiles = shinobu.getArchiveFileList(id)
        
        // 如果不需要只返回图片文件，获取所有文件
        if (!imagesOnly) {
            // 这里可以添加获取所有文件的逻辑
            // 目前保持只返回图片文件
        }
        
        // 构建页面URL列表
        var pagesJson = "["
        for (i in 0..pageFiles.size) {
            if (i > 0) {
                pagesJson = pagesJson + ","
            }
            // 修正URL格式，使用 ? 而不是 &
            let pageUrl = "/api/archives/${id}/page?path=${pageFiles[i]}"
            pagesJson = pagesJson + "\"${pageUrl}\""
        }
        pagesJson = pagesJson + "]"
        
        // 构建响应JSON
        var responseJson = "{"
        responseJson = responseJson + "\"pages\":${pagesJson}"
        responseJson = responseJson + "}"
        
        ctx.json(responseJson)
    }

    // GET /api/archives/{id}/files/{fileIndex}
    public static func getFile(ctx: JoyContext): Unit {
        let id = ctx.getParam("id").getOrThrow()
        let fileIndex = ctx.getParam("fileIndex").getOrThrow()
        let filePath = ArchiveModel.getArchiveFile(id)

        let result = "{\"file\":\"${filePath}\",\"index\":\"${fileIndex}\"}"
        ctx.json(result)
    }

    // POST /api/archives/{id}/extract
    public static func extractArchive(ctx: JoyContext): Unit {
        let id = ctx.getParam("id").getOrThrow()
        // 简化实现，返回一个任务ID
        let taskId = "task_${id}_${Int64(1234567890)}"
        let result = "{\"operation\":\"extract_archive\",\"data\":{\"task_id\":\"${taskId}\"},\"success\":1}"
        ctx.json(result)
    }

    // DELETE /api/archives/{id}
    public static func deleteArchive(ctx: JoyContext): Unit {
        let id = ctx.getParam("id").getOrThrow()
        // 简化实现，总是返回成功
        let result = "{\"operation\":\"delete_archive\",\"success\":1}"
        ctx.json(result)
    }

    // GET /api/archives/{id}/download
    public static func downloadArchive(ctx: JoyContext): Unit {
        let id = ctx.getParam("id").getOrThrow()
        
        // 检查ID是否为空
        if (id.size == 0) {
            let errorResponse = "{\"operation\":\"download_archive\",\"error\":\"No archive ID specified.\",\"success\":0}"
            ctx.status(HttpStatusCode.STATUS_BAD_REQUEST)
            ctx.json(errorResponse)
            return
        }
        
        // 检查归档是否存在
        let archive = ArchiveModel.getArchiveById(id)
        if (archive.id.size == 0) {
            let errorResponse = "{\"operation\":\"download_archive\",\"error\":\"Archive not found\",\"success\":0}"
            ctx.status(HttpStatusCode.STATUS_NOT_FOUND)
            ctx.json(errorResponse)
            return
        }
        
        // 获取ShinobuService实例
        let shinobu = ShinobuService.getInstance()
        
        // 构建归档文件完整路径
        let archivePath = ShinobuService.getArchivePath().toString()
        let fullArchivePath = if (archive.relative_path.size > 0) {
            "${archivePath}/${archive.relative_path}/${archive.filename}"
        } else {
            "${archivePath}/${archive.filename}"
        }
        
        // 检查文件是否存在并读取文件内容
        try {
            let filePath = Path(fullArchivePath)
            let file = File(filePath, Read)
            let fileInfo = file.info
            let fileSize = fileInfo.size
            let buffer = Array<Byte>(fileSize, {_ => 0})
            let bytesRead = file.read(buffer)
            file.close()
            
            // 设置响应头
            ctx.header("Content-Type", "application/octet-stream")
            ctx.header("Content-Disposition", "attachment; filename=\"${archive.filename}\"")
            ctx.header("Content-Length", "${fileSize}")
            ctx.status(HttpStatusCode.STATUS_OK)
            
            // 返回文件内容
            ctx.data(buffer)
        } catch (e: Exception) {
            let errorResponse = "{\"operation\":\"download_archive\",\"error\":\"Failed to read archive file: ${e.message}\",\"success\":0}"
            ctx.status(HttpStatusCode.STATUS_INTERNAL_SERVER_ERROR)
            ctx.json(errorResponse)
        }
    }

    // GET /api/archives/{id}/page
    public static func getPage(ctx: JoyContext): Unit {
        let id = ctx.getParam("id").getOrThrow()
        
        // 检查ID是否为空
        if (id.size == 0) {
            let errorResponse = "{\"operation\":\"serve_page\",\"error\":\"No archive ID specified.\",\"success\":0}"
            ctx.status(HttpStatusCode.STATUS_BAD_REQUEST)
            ctx.json(errorResponse)
            return
        }
        
        // 获取查询参数
        let pathParam = ctx.getQuery("path")
        match (pathParam) {
            case Some(path) =>
                if (path.size == 0) {
                    let errorResponse = "{\"operation\":\"serve_page\",\"error\":\"No path specified.\",\"success\":0}"
                    ctx.status(HttpStatusCode.STATUS_BAD_REQUEST)
                    ctx.json(errorResponse)
                    return
                }
                
                // 检查归档是否存在
                let archive = ArchiveModel.getArchiveById(id)
                if (archive.id.size == 0) {
                    let errorResponse = "{\"operation\":\"serve_page\",\"error\":\"Archive not found\",\"success\":0}"
                    ctx.status(HttpStatusCode.STATUS_NOT_FOUND)
                    ctx.json(errorResponse)
                    return
                }
                
                // 获取ShinobuService实例
                let shinobu = ShinobuService.getInstance()
                
                // 构建归档文件完整路径
                let archivePath = ShinobuService.getArchivePath().toString()
                let fullArchivePath = if (archive.relative_path.size > 0) {
                    "${archivePath}/${archive.relative_path}/${archive.filename}"
                } else {
                    "${archivePath}/${archive.filename}"
                }
                
                // 使用bsdtar直接提取文件到内存，不写入文件
                try {
                    // 使用 bsdtar 的 -xO 选项直接输出到标准输出
                    let (exitCode, stdout, stderr) = shinobu.extractArchiveEntryToStream(fullArchivePath, path)
                    
                    if (exitCode == 0) {
                        // 根据文件扩展名设置Content-Type
                        let contentType = getContentTypeFromPath(path)
                        ctx.header("Content-Type", contentType)
                        ctx.status(HttpStatusCode.STATUS_OK)
                        // 直接返回二进制数据
                        ctx.data(stdout)
                    } else {
                        let error = String.fromUtf8(stderr)
                        let errorResponse = "{\"operation\":\"serve_page\",\"error\":\"Failed to extract file: ${error}\",\"success\":0}"
                        ctx.status(HttpStatusCode.STATUS_INTERNAL_SERVER_ERROR)
                        ctx.json(errorResponse)
                    }
                } catch (e: Exception) {
                    let errorResponse = "{\"operation\":\"serve_page\",\"error\":\"Exception extracting file: ${e.message}\",\"success\":0}"
                    ctx.status(HttpStatusCode.STATUS_INTERNAL_SERVER_ERROR)
                    ctx.json(errorResponse)
                }
            case None =>
                let errorResponse = "{\"operation\":\"serve_page\",\"error\":\"No path specified.\",\"success\":0}"
                ctx.status(HttpStatusCode.STATUS_BAD_REQUEST)
                ctx.json(errorResponse)
        }
    }
    
    /**
     * 根据文件路径获取Content-Type
     */
    private static func getContentTypeFromPath(filePath: String): String {
        if (filePath.endsWith(".jpg") || filePath.endsWith(".jpeg")) {
            return "image/jpeg"
        } else if (filePath.endsWith(".png")) {
            return "image/png"
        } else if (filePath.endsWith(".gif")) {
            return "image/gif"
        } else if (filePath.endsWith(".bmp")) {
            return "image/bmp"
        } else if (filePath.endsWith(".webp")) {
            return "image/webp"
        } else {
            return "application/octet-stream"
        }
    }

    // PUT /api/archives/upload
    public static func uploadArchive(ctx: JoyContext): Unit {
        try {
            // 检查是否是分片上传
            let uploadIdOpt = ctx.getQuery("uploadId").getOrThrow()
            let chunkIndexOpt = Int64.parse(ctx.getQuery("chunkIndex").getOrThrow())
            let totalChunksOpt = Int64.parse(ctx.getQuery("totalChunks").getOrThrow())
            
            if (uploadIdOpt.size>0 && chunkIndexOpt > 0 && totalChunksOpt > 0) {
                handleChunkUpload(ctx, uploadIdOpt, chunkIndexOpt, totalChunksOpt)
                return
            }
            
            // 原有的单文件上传逻辑
            handleSingleFileUpload(ctx)
        } catch (e: Exception) {
            let errorResponse = "{\"operation\":\"upload\",\"error\":\"${e.message}\",\"success\":0}"
            ctx.status(HttpStatusCode.STATUS_INTERNAL_SERVER_ERROR)
            ctx.json(errorResponse)
        }
    }
    
    /**
     * 处理分片上传
     */
    private static func handleChunkUpload(ctx: JoyContext, uploadId: String, chunkIndex: Int, totalChunks: Int): Unit {
        // 分片上传配置
        let CHUNK_SIZE = 1536 * 1024 // 1.5MB (小于2MB限制)
        
        // 创建临时目录
        let tempDirStr = "./temp_chunks"
        let tempDir = Path(tempDirStr)
        if (!exists(tempDir)) {
            Directory.create(tempDir, recursive: true)
        }
        
        // 确保最终上传目录存在（用于合并后的文件）
        let finalUploadDir = Path("./data/cache/uploads")
        if (!exists(finalUploadDir)) {
            Directory.create(finalUploadDir, recursive: true)
        }
        
        // 创建上传会话目录
        let uploadDir = Path("${tempDirStr}/${uploadId}")
        if (!exists(uploadDir)) {
            Directory.create(uploadDir, recursive: true)
        }
        
        // 保存分片文件
        let chunkFile = Path("${uploadDir}/chunk_${chunkIndex}.bin")
        let fileData = ctx.readRawData()
        
        try (file = File(chunkFile, Write)) {
            file.write(fileData)
        }
        
        // 检查是否所有分片都已上传
        var uploadedCount = 0
        for (i in 0..totalChunks) {
            let checkFile = Path("${uploadDir}/chunk_${i}.bin")
            if (exists(checkFile)) {
                uploadedCount++
            }
        }
        
        // 如果所有分片都已上传，合并文件
        if (uploadedCount == totalChunks) {
            let fileName = ctx.getQuery("filename") ?? "merged_file.bin"
            let finalFile = Path("${tempDirStr}/${fileName}")
            
            // 合并分片
            try (outputFile = File(finalFile, Append)) {
                for (i in 0..totalChunks) {
                    let chunkPath = Path("${uploadDir}/chunk_${i}.bin")
                    if (exists(chunkPath)) {
                        let chunkFile = File(chunkPath, Read)
                        let fileSize = chunkFile.length
                        let chunkData = Array<Byte>(fileSize, {_ => 0 })
                        chunkFile.read(chunkData)
                        outputFile.write(chunkData)
                    }
                }
            }
            
            // 清理分片目录
            let uploadDirStr = uploadDir.toString()
            for (entry in Directory.readFrom(uploadDir)) {
                remove(entry.path, recursive: true)
            }
            remove(uploadDir)
            
            // 返回成功响应
            let successResponse = "{\"operation\":\"upload\",\"success\":1,\"message\":\"All chunks merged\"}"
            ctx.json(successResponse)
        } else {
            // 返回分片上传成功响应
            let successResponse = "{\"operation\":\"upload\",\"success\":1,\"chunkIndex\":${chunkIndex},\"uploaded\":${uploadedCount},\"total\":${totalChunks}}"
            ctx.json(successResponse)
        }
    }
    
    /**
     * 处理单文件上传（原有逻辑）
     */
    private static func handleSingleFileUpload(ctx: JoyContext): Unit {
        try {
            // 获取查询参数
            let title = ctx.getQuery("title") ?? ""
            let tags = ctx.getQuery("tags") ?? ""
            let summary = ctx.getQuery("summary") ?? ""
            let categoryIdStr = ctx.getQuery("category_id") ?? ""
            let fileChecksum = ctx.getQuery("file_checksum") ?? ""
            let fileName = ctx.getQuery("filename") ?? ""
            
            // 验证必要参数
            if (fileName.size == 0) {
                let errorResponse = "{\"operation\":\"upload\",\"error\":\"No filename specified\",\"success\":0}"
                ctx.status(HttpStatusCode.STATUS_BAD_REQUEST)
                ctx.json(errorResponse)
                return
            }
            
            // 检查文件扩展名是否支持
            let fileExtension = FileUtils.getFileExtension(fileName)
            let supportedExtensions = ["zip", "rar", "7z", "tar", "gz", "cbz", "cbr", "cb7", "cbt"]
            
            if (!supportedExtensions.contains(fileExtension)) {
                let errorResponse = "{\"operation\":\"upload\",\"error\":\"Unsupported File Extension (${fileName})\",\"success\":0,\"id\":\"deadbeef\"}"
                ctx.status(HttpStatusCode.STATUS_UNSUPPORTED_MEDIA_TYPE)
                ctx.json(errorResponse)
                return
            }
            
            // 创建临时目录
            let tempDirStr = "./temp_uploads"
            let tempDir = Path(tempDirStr)
            if (!exists(tempDir)) {
                Directory.create(tempDir, recursive: true)
            }
            
            let tempFilePath = tempDir.join(fileName)
            
            // 从请求体中读取文件数据并保存到临时文件
            // 先尝试读取请求体
            let fileData = ctx.readRawData()
            println("Received file data size: ${fileData.size}")
            
            if (fileData.size == 0) {
                let errorResponse = "{\"operation\":\"upload\",\"error\":\"No file data provided\",\"success\":0}"
                ctx.status(HttpStatusCode.STATUS_BAD_REQUEST)
                ctx.json(errorResponse)
                return
            }
            
            // 写入临时文件
            try (file = File(tempFilePath, Write)) {
                file.write(fileData)
            }
            
            // 确保文件已正确写入
            if (!exists(tempFilePath)) {
                let errorResponse = "{\"operation\":\"upload\",\"error\":\"Failed to save uploaded file\",\"success\":0}"
                ctx.status(HttpStatusCode.STATUS_INTERNAL_SERVER_ERROR)
                ctx.json(errorResponse)
                return
            }
            
            println("File saved to: ${tempFilePath.toString()}, size: ${fileData.size} bytes")
            
            // 获取ShinobuService实例
            let shinobu = ShinobuService.getInstance()
            let archivePath = ShinobuService.getArchivePath().toString()
            
            // 构建目标文件路径
            let targetFilePath = FileUtils.joinPath(archivePath, fileName)
            
            // 打印调试信息
            println("Processing upload: fileName=${fileName}, fileSize=${fileData.size}, tempPath=${tempFilePath.toString()}")
            
            // 检查文件是否已存在
            if (shinobu.checkFileExists(targetFilePath)) {
                println("File already exists: ${targetFilePath}")
                let existingArchive = ArchiveDao.getByPathAndFilename("", fileName)
                match (existingArchive) {
                    case Some(archive) =>
                        let errorResponse = "{\"operation\":\"upload\",\"error\":\"This file already exists in the Library. Enable replace duplicated archive in config to replace old ones.\",\"success\":0,\"id\":\"${archive.id}\"}"
                        ctx.status(HttpStatusCode.STATUS_CONFLICT)
                        ctx.json(errorResponse)
                        return
                    case None =>
                        // 文件存在但数据库中没有记录，继续处理
                        println("File exists but not in database, proceeding: ${targetFilePath}")
                }
            }
            
            // 如果提供了校验和，验证文件完整性
            if (fileChecksum.size > 0) {
                println("Verifying checksum: ${fileChecksum}")
                let calculatedChecksum = shinobu.generateFileHashForUpload(tempFilePath.toString())
                if (calculatedChecksum != fileChecksum) {
                    let errorResponse = "{\"operation\":\"upload\",\"error\":\"Checksum mismatch: expected ${fileChecksum}, got ${calculatedChecksum}\",\"success\":0}"
                    ctx.status(HttpStatusCode.STATUS_EXPECTATION_FAILED)
                    ctx.json(errorResponse)
                    return
                }
            }
            
            println("Moving file from ${tempFilePath.toString()} to ${targetFilePath}")
            rename(tempFilePath, to: Path(targetFilePath))
            
            try {
                // 创建一个简单的归档ID
                let archiveId = "archive_${FileUtils.getFileExtension(fileName)}_12345"
                
                // 返回成功响应
                let successResponse = "{\"operation\":\"upload\",\"success\":1,\"id\":\"${archiveId}\"}"
                ctx.json(successResponse)
                return
            } catch (e: Exception) {
                println("Failed to move file: ${e.message}")
                let errorResponse = "{\"operation\":\"upload\",\"error\":\"Failed to save archive file\",\"success\":0}"
                ctx.status(HttpStatusCode.STATUS_INTERNAL_SERVER_ERROR)
                ctx.json(errorResponse)
                return
            }
            
            
        } catch (e: Exception) {
            let errorResponse = "{\"operation\":\"upload\",\"error\":\"${e.message}\",\"success\":0}"
            ctx.status(HttpStatusCode.STATUS_INTERNAL_SERVER_ERROR)
            ctx.json(errorResponse)
        }
    }
}